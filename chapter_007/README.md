# Chapter_007 "Concurrency"

1. Threads 
    a) Создать программу, которая будет считать количество и пробелом в тексте.
       Необходимо создать два Thread. Первый будет считать количество слов. Второй количество пробелом в тексте.
       Вывести результат на экран.
       Продемонстрировать, что программа выполняется параллельно. Это будет видно по выводу.
    b) Необходимо, что бы вначале запуска программы из первой части на экране выводилась информация о программа. А после вычисления данных, выводилась запись о завершении программы. Важно, эта информация всегда должна выводиться в начале и в конце вычисления.
       Предусмотреть возможность останавливать вычисления, если время вычисления превышает 1 секунде. Для этого нужно реализовать проверку поведения isInterrunt()
    c) Реализовать механизм программнной остановки потока. 
    
2. JMM
    a) Создать пример иллюстрирующий проблемы, которые могут случиться при использовании многопоточности. 
   
3. Monitore, Synchronize
    a) Сделать класс многопоточный счетчик Count#int incremant() продемонстрировать работу через два потока.
       Дополнительное задание, можно не делать. предложить 4 различных решения. 
    b) Создать класс хранилища пользователей UserStorage. В него можно добавлять новых пользователей. 
       Редатировать. Удалять и читать. У пользователя есть поле amount. 
       Нуждо добавить метод перечисления денег с одного пользователя на другой. Код должен быть ThreadSafe. 
    c) Реализовать ThreadSafe динамический список и связанный список из заданий модуля коллекции. 
    d) 1. Нужно осуществлять обход файловой системы и поиск заданного текста в файловой системе. 
          Приложение многопоточное, запускается из командной строки и принимает аргумент как параметр поиска.
       2. Предусмотреть возможность останавливать поиск. если хотя бы один тред нашел совпадение. 
       Cделать это через флаг запуска.
4. Wait, Notify, NotifyAll
    a)  Реализовать шаблон Producer Customer. Это структура данных на основании блокирующей очереди.
       Producer - добавляет данные, а Customer их забирает. если данных нет. то блокировать тред до появления новых данных.
    b)  Инициализация пула должна быть по количеству ядер в системе.
       2. создать метод add(Work work).
       3. Если есть свободные треды, начать выполнение работы. если нет. то в очередь до появления свободного треда. 
    c)  Реализовать собственный механизм блокировок Lock. на основе synch wait notify.
    
5. Non blocking algorithm 
    a) 1. Необходимо сделать кеш для хранение моделей. в кеше должны быть методы 
       add, update delete, 
       2. Кеш должен работать на неблокирующих алгоритмах. - использовать ConcurrencyHashMap
       3. В кеше должна быть возможность проверять валидность данных. Например: 
          Два пользователя прочитали данные task_1 первый пользователь изменил поле имя и второй сделал тоже самое. 
          Нужно перед обновлением данных проверить. что текущий пользователь не затер данные другого пользователя. 
          Если данные затерты то выбросить OplimisticException - такая реализация достигается за счет введение в 
          модель поля version и перед обновлением данных проверять текущую версию и ту что обновляем и увеличивать 
          на один каждый раз когда обновили. Если версии не равны то кидать исключение.
6. Additional task
    a) Реализовать игру бомбермен. Без графики. Без меню и без пользовательского ввода.
       Интересует только логика и дизайн.
       1. Есть игровое поле - двухмерный массив. Есть герои - Бомбермен и чудовища. 
       2. Приложение не должно блокировать все игровое поле.
       3. В поле должны существовать блоки. поля куда нельзя ходить.
       4. Бомбермен должен управляться через пользователя. (Пользовательский ввод реализовывать не надо) только апи, для движения.
       5. Чудовища должны двигаться автоматически. 
       6. Предусмотреть, что если чудовище не может двинуться на клетку. например, там стоит другое чудовище, проверять в течении .5 секунд и двигаться в другую строну.
<<<<<<< HEAD
       7. Сложность поля и количество чудовищ должно варьироваться. 
=======
       7. Сложность поля и количество чудовищ должно варьироваться. 
>>>>>>> origin/master
